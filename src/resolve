/*
   Copyright 2015 Daniel Jay Haskin

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
constraint: version string, constraint string

any given tool has a suite of what's going on:

pretty much all of these are static

package_properties:
    validate name
    validate version
    compare versions
    validate constraint relationship
    constraint string -> (name, version, relationship)
    check constraint

package_tool:
    name -> listof constraints

repositoryIO: operator () taking a name and returning a map from versions to files.
struct file: url, checksum (maybe).

package_tool:
resolver: package_properties, package_tool, repository




resolve(const std::map<name, std::list<constraints> > order) {

    std::list<file> returned;
    for (auto package : order) {
        std::string name = package.first;
        std::list<constraint> constraints = package.second;
        std::map<version, file> candidates = this->repository.query(name);

        for (auto constraint : constraints) {
            std::remove_if(candidates.begin(), candidates.end(),
                    this->package_properties.satisfies(constraint))
        }

        if (candidates.empty() ) {
            return returned;
        }

        candidates = sort(candidates,
            []{ return -1 * this->package_properties.vercmp(); } );

        for (auto candidate : candidates) {
            auto candidate_version = candidate.first;
            auto candidate_file = candidate.second;
            auto candidate_deps =
                this->repository.query_dependencies(name, candidate_version);
            auto candidate_dep_files = resolve(candidate_deps);
            if (!candidate_dep_files.empty()) {
                returned = returned + candidate_dep_fils; // concatenate lists, use move semantics if possible
                returned.push_back(candidate_file);
                break;
            }
        }
    }
}
